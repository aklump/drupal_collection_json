<?php
/**
 * @file
 * Base file for the collection_json module.
 *
 * @defgroup collection_json Collection Json
 * @{
 */
use \AKlump\Http\CollectionJson\Collection;

// Path to the admin settings form
define('COLLECTION_JSON_URL_SETTINGS', 'admin/config/system/collection-json');

/**
 * Include (or return include path to) a collection_json include file(s)
 *
 * @code
 *   'file' => collection_json_include('pages', 2),
 * @endcode
 *
 * @param... string
 *   Any number of include file keys to include
 *   For includes/collection_json.example.inc, set this to: example
 * @param int $action
 *   The final argument, if numeric is one of.  If omitted 1 is the default.
 *   1: include the module(s)
 *   2: return the path relative to the module, e.g., hook_menu()
 *   3: return the complete Drupal path per drupal_get_path()
 *
 * @return string
 *   The path to the FIRST include file requested, but only if $return is set to TRUE
 */
function collection_json_include() {
  $includes = func_get_args();
  if (is_numeric(end($includes))) {
    $action = array_pop($includes);
  }
  else {
    $action = 1;
  }
  if ($action > 1) {
    $module = 'includes/collection_json.' .  reset($includes) . '.inc';
    switch ($action) {
      case 3:
        $module = drupal_get_path('module', 'collection_json') . '/' . $module;
        break;
    }
    return $module;
  }
  reset($includes);
  foreach ($includes as $include_name) {
    module_load_include('inc', 'collection_json', 'includes/collection_json.' . $include_name);
  }
}

/**
 * Implements hook_admin_paths().
 */
function collection_json_admin_paths() {
  return array('help/*');
}

/**
 * Triggered when the REST server request a list of available request parsers.
 *
 * @param array $parsers
 *  An associative array of parser callbacks keyed by mime-type.
 * @return void
 */
function collection_json_rest_server_request_parsers_alter(&$parsers) {
  $parsers['application/vnd.collection+json'] = 'RESTServerCollectionJSON::parseCollectionJSON';
}

/**
 * Triggered when the REST server request a list of supported response formats.
 *
 * @param array $formatters
 *  An associative array of formatter info arrays keyed by type extension. The
 *  formatter info specifies an array of 'mime types' that corresponds to the
 *  output format; a 'view' class that is a subclass of RESTServerView; and
 *  'view arguments' that should be passed to the view when it is created;
 *  a 'model' can also be specified which the controller then must declare
 *  support for to be able to serve data in that format.
 * @return void
 */
function collection_json_rest_server_response_formatters_alter(&$formatters) {

  // Set this up to be able to convert our custom object if needed
  foreach ($formatters as $key => $value) {
    if ($formatters[$key]['view'] === 'RESTServerViewBuiltIn') {
      $formatters[$key]['view arguments']['view'] = $formatters[$key]['view'];
      $formatters[$key]['view'] = 'RESTServerViewCollectionJSON';
    }
  }

  $formatters['collection_json'] = array(
    'mime types' => array('application/vnd.collection+json'),
    'view' => 'RESTServerViewCollectionJSON',
    'view arguments' => array('format' => 'collection_json'),
  );
}

/**
 * Load the necessary library files to make classes available
 *
 * Use this whenever you need to instantiate an object.  For classes refer
 * to vendor/AKlump/Http.  For example usage take a look at:
 * includes/RESTServerCollectionJSON.php
 */
function collection_json_load() {
  if (collection_json_config()->autoload) {
    module_load_include('php', 'collection_json', 'vendor/autoload');
  }
}

/**
 * Return a config array
 *
 * @return object
 *   - autoload: TRUE if this module should load the classes from it's library.
 */
function collection_json_config() {
  $config = &drupal_static(__FUNCTION__, new \stdClass);
  if (empty($config)) {
    $config->autoload = TRUE;
    drupal_alter('collection_json_config', $config);
  }

  return $config;
}

/**
 * Implements hook_rest_server_execute_errors_alter().
 */
function collection_json_rest_server_execute_errors_alter($error_array, $controller, $arguments) {
  $obj = collection_json_new_collection();
  $title = str_replace(': ' . $error_array['body_data'], '', $error_array['header_message']);
  $title = trim(str_replace($error_array['code'], '', $title));
  $obj->setError(new \AKlump\Http\CollectionJson\Error($error_array['code'], $title, $error_array['body_data']));
  $error_array['body_data'] = $obj;
}

/**
 * Returns a new collection object with the current page as the href
 *
 * @return \AKlump\Http\CollectionJson\Collection
 */
function collection_json_new_collection() {
  collection_json_load();

  return new Collection(url(current_path(), array('absolute' => TRUE)));
}

/**
 * Build an Item based on an entity.
 *
 * @param  string $entity_type E.g. node
 * @param  object $entity      
 * @param  string $uri         
 * @param  array  $params      An optional array of custom params. These can be
 *   used by the hook_alters.
 *
 * @return \AKlump\Http\CollectionJson\Item
 */
function collection_json_entity_item($entity_type, $entity, $uri, $params = array()) {
  $href = services_resource_uri(array($uri));
  $item = new \AKlump\Http\CollectionJson\Item($href);

  

  drupal_alter('collection_json_entity_item', $item, $entity_type, $entity, $params);

  return $item;
}

/**
 * Helper function to build a query data array for a resource/type
 *
 * @param  string $resource_name
 * @param  string $crud_type Should be 'retrieve'||'index'
 *
 * @return array An array of Data objects.
 */
function collection_json_query_data($resource_name, $crud_type) {
  $query_data = array();
  if (!($r = services_get_resources()) || empty($r['cycles']['operations']['retrieve']['args'])) {
    return $data;
  }
  foreach ($r[$resource_name]['operations'][$crud_type]['args'] as $data) {
    if (isset($data['source']['param'])) {
      $default  = array_key_exists('default value', $data) ? $data['default value'] : '';
      $prompt   = isset($data['description']) ? $data['description'] : '';
      $query_data[]   = new \AKlump\Http\CollectionJson\Data($data['source']['param'], $default, $prompt);
    }
  }

  return $query_data;
}

/**
 * Build a Template object based on an entity/bundle
 *
 * @param  string $entity_type
 * @param  string $bundle_name
 *
 * @return \AKlump\Http\CollectionJson\Template
 */
function collection_json_bundle_template($entity_type, $bundle_name) {
  $template = new \AKlump\Http\CollectionJson\Template();



  drupal_alter('collection_json_bundle_template', $template, $entity_type, $bundle_name);

  return $template;
}

/**
 * Delete a node and set a 204 header per collection specs.
 *
 * @see  http://amundsen.com/media-types/collection/format/#general
 *
 * @param  int $nid
 */
function collection_json_node_resource_delete($bundle_type, $nid) {
  if (!($node = node_load($nid)) || $node->type !== $bundle_type) {
    return services_error('Resource not found', 404);
  }
  node_delete($nid);
  if (node_load($nid)) {
    return services_error('Could not delete resource.', 409);
  }
  else {
    drupal_add_http_header('Status', '204 No Content');
  }
}